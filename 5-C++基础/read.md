# 技术基础（第三周~第四周）

### 参考书目：c++ primer或java高级编程、深入理解计算机系统、mysql文档、网络

  C++或java基础语法
  掌握一门后台语言，熟悉c++或java的基础语法
  了解面向对象思想
  了解虚拟函数、反射的基本原理；
  

### Cpu、内存
  a —— 了解cpu和程序执行的关系；
      首先，CPU的规则，取指令、指令译码、执行指令、访存取数和结果写回的过程。
      程序最终都会转化为计算，CPU就是来处理计算的，并且管理程序运行时的存储的问题，
  比如，中断来了，要缓存当时的环境，之后，还需要还原。

  b —— cpu资源争抢机制：

      1、队列方式：先来先服务。不管是什么任务来了都要按照队列排队先来后到。

      2、时间片轮转：设定一个时间片，每个任务使用cpu的时间不能超过这个时间。
         如果超过了这个时间就把任务暂停保存状态，放到队列尾部继续等待执行。
      
      3、优先级方式：给任务设定优先级，有优先级的先执行，没有优先级的就等待执行。

    
  c —— 了解内存回收机制：
      先百度一个概念——根集。我的理解是，有个全局的执行环境，这个执行环境下有一套可以
  维护的变量体系，把这个体系比做一个树。比较类似的想法是MFC的实现，维护一套变量的体系，
  从上到下，从全局到局部作用域中的变量都可以访问到，能访问到的，都认为是活动对象。不能
  访问的，其实是可以干掉的。

      1） 引用计数法：
            与根集无关，对对象用一次，就进行一次计数，一旦计数是0，就干掉。

      2） tracing算法(Tracing Collector)
            与根集有关，基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，
        哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。
        在扫描识别过程中，垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器. 

      3） compacting算法(Compacting Collector) 
            移动内存中产生的碎片，移动到一端，另一端就是空闲了。收集器会对它移动的所有对象
        的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的
        收集器的实现中，一般增加句柄和句柄表。　　 
  
      4） copying算法(Coping Collector) 
            该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象面
        和多个空闲面，程序从对象面为对象分配空间，当对象满了，基于coping算法的垃圾收集就从根集
        中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞），
        这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。 
        stop-and-copy


      5）generation算法(Generational Collector) 
　　          stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，
          这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间
          比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代(generation)。由于多
          数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在
          分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常
          被回收，因而节省了时间。 


        总结一下，就是计数和tracing。但是，计数有个问题，就是循环引用的问题，应该大部分，都是采取
      判断是否可以用，这样的方式简单。



  d —— 了解内存泄露的原因：
        内存泄露是由于内存被申请了，但是由于种种原因并没有被释放。
    这样导致其他程序也无法使用这段地址了。

        根本原因：动态分配了内存，但是没有回收。


### 进程、线程
  
      定义进程：系统进行资源分配和调度的基本单位。是操作系统执行的基本单元。
      定义线程：是程序执行流的最小单元。
  

  a —— 了解进程空间的结构及特点

    进程主要有两点：
        第一): 进程是一个实体。每一个进程都有它自己的地址空间，
                包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。
                文本区域存储处理器执行的代码；
                数据区域存储变量和进程执行期间使用的动态分配的内存；
                堆栈区域存储着活动过程调用的指令和本地变量。

        第二): 进程是一个“执行中的程序”。
              程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之),
              它才能成为一个活动的实体，我们称其为进程。
  


    特征：

        动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
        并发性：任何进程都可以同其他进程一起并发执行；
        独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
        异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进；
        结构特征：进程由程序、数据和进程控制块三部分组成。



    状态：其实根操作系统的任务很像，三态控制。
          
          1）就绪状态（Ready）
          2）运行状态(Running)：
          3）阻塞状态(Blocked)：

    进程的空间结构：
        分别是代码段，数据断，和堆栈段。

        1）代码段：用于保存可执行文件的操作指令和程序定义的常量。其只允许读，不能进行修改。
        目的是为了防止代码在运行的时候被其他进程修改。一个程序可以由多个进程组成，多个进程
        可以共享相同的代码段，即当程序被多次执行时，运行相同程序将共享代码段。那麽不同程序
        间代码断是不能共享的。

        2、数据段：他的位置紧跟着代码段，分为初始化数据段和为初始化数据段。前者用于存放已经
        初始化的全局变量和静态变量，后者用于保存为初始化的全局变量。

        3、堆栈段：堆栈段中的堆用于存放进程中动态分配的内存地址，如，malloc，new函数分配的
        空间都将在堆中分配，当free火delete时，分配的内存将从中删除。栈用于保存程序中创建的
        临时变量。函数调用时，传递函数也将被保存在栈中。在函数调用结束后，其返回也将保存在栈
        中。起具有先进先出的特点，适合用于保存和恢复现场。可以将栈看作用于存放临时数据，进行
        数据交换的内存区域。其大小受操作系统限制，因此从栈中获得的空间大小有限，而堆的大小只
        是受限于虚拟内存空间，因此使用堆可以获得较大的内存空间，对的位置于数据段临。



  b —— 进程线程的区别；
        
        应用程序可以有多个进程，进程是操作系统的资源分配的最小单位，
        一个进程是可以有多个线程的，线程是一个进程的原子操作。
      
  c —— 多进程和多线程
      
        操作系统的设计，因此可以归结为三点：
        （1）以多进程形式，允许多个任务同时运行；
        （2）以多线程形式，允许单个任务分成不同的部分运行；
        （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

  d —— 临界资源和锁机制

        简单的理解就是，不能同时读写一个区域，这样会造成数据错乱。
        所以需要加入信号灯机制。加锁和解锁，一个进程对临界区加锁，
        其他进程试图访问该临界区时，会被设置成睡眠状态，
        然后被放入等待该锁的队列中。当加锁的进程解锁临界区之后，
        会从该锁的等待队列中寻找一个进程将其设置为就绪，等待调度。



### 文件io
  文件读写原理；

    首先open －> read || write -> close;

    无论是什么格式的file，维护了一个数据结构，这个结构里面，会包含着文件的机构的信息，
    比如文件多大\类型，起始地址，终止地址，如果文件过大，可能会存到不同的扇区里面，
    这样，要维护一个链表，保证地址的链接有效并且有序。
    读写一般都是有偏移量的，可以操作特定的位置的内容。
    读写还是有权限的，不同的用户可能拥有不同的权限。


  文件锁机制：
      百度了一下，有2种常用的文件锁，

      1、  协同锁
            协同锁要求参与操作的进程之间协同合作。
            假设进程“A”获得一个WRITE锁，并开始向文件中写入内容；此时，进程“B”并没有试图获取一个锁，
        它仍然可以打开文件并向文件中写入内容。在此过程中，进程“B”就是一个非合作进程。如果进程“B”试图
        获取一个锁，那么整个过程就是一个合作的过程，从而可以保证操作的“序列化”。

        只有当参与操作的进程是协同合作的时候，协同锁才能发挥作用。协同锁有时也被称为“非强制”锁。



      2、  强制锁
            强制锁不需要参与操作的进程之间保持协同合作。它利用内核来查检每个打开、读取、写入操作，
        从而保证在调用这些操作时不违反文件上的锁规则。

      思考几种场景：
          （1）同时读，肯定可以；
          （2）同时写，需要加锁，保证写的有序，并且不覆盖；
          （3）一读一写，注意读写顺序，保证读的有意义。写的有价值。



### 性能及算法

  同步异步含义及区别；
      
      同步————可以理解为顺序执行，举个例子——应答，发送一个数据，
  发送方只有接到应答才会继续发送下面的数据。
      
      异步————发送方不等到接受方的应答，就继续发送下面的数据。
  
  举个例子：普通B/S（同步）AJAX（异步）
  
    同步 ———— 提交请求-——>等待服务器处理-——>处理完毕返回。［这个期间客户端浏览器不能干任何事］
  
    异步 ———— 请求通过事件触发-——>服务器处理［这是浏览器仍然可以作其他事情］-——>处理完毕

    同步是阻塞模式，异步是非阻塞模式


  异步promise模式；

        promise：就是让开发看起来像顺序执行，这样理解起来比较舒服吧。
    promise有三态，但是这个三态不像进程或者任务的态，首先不可逆，其次，
    执行方向比较单一。
      只能从pending-->resolve | reject.

        promise维护了一个列表，它可以将任务全部压入队列中，而后，开始执行，
    不过，有些可能可以，一边执行，一边压入，不过这个不重要。反正，就是当前一
    个任务执行完成以后，会有2个状态，要么成功，要么失败。进行处理。然后，再继
    续执行队列里面的其它任务。从而达到，顺序执行的目的。


      



  缓存含义及用途；
  
        应用程序中缓存数据有以下好处
          1）减少交互的通讯量  ————  缓存数据能有效减少在进程和机器间的传输量；
          2）降低系统中的处理量  ————   减少处理次数；
          3）降低需要做的磁盘访问次数  ————  比如缓存在内存中的数据。


        
        存储在哪里：
          1)存储类型Storage Type——数据可用的物理存储位置；
          2)层间的架构元素（Layered architecture elements）——数据可用的逻辑存储位置。
          
          web端  ————   以前，大家都放到浏览器的cookie中，现在本地存储比较盛行，也比较大。
          服务端  ————   放入memcached 或者 radis中，减少对数据库的访问。




  了解常用算法，包括数组、链表、二叉树、红黑树、hash等
  

      红黑树： 我对这个很不熟悉。所以需要看看。看完感觉很好玩。

      B树
      B－
      B+

      红黑树：
            红黑树通过红黑节点的关系，优化了树的高度，
            最长的查找距离是2倍黑树的个数。提升了查找速度，
            本质上，还是时间换空间。

          红黑树有5条规则，符合5条规则的二叉树，就是红黑树。
      插入节点的时候，就是调整树的颜色，如果无法达到要求，就
      只能调整节点的位置。进行条件匹配。











### 数据库
  
  a —— 了解mysql，用户权限及备份机制；
        
        use mysql;

        select host, user form user;


        +-----------+-----------+
        | host      | user      |
        +-----------+-----------+
        | localhost | mysql.sys |
        | localhost | root      |
        +-----------+-----------+
              

  
  b —— 掌握基本使用，包括建表，sql执行



### 架构模式
  了解mvc架构、n层结构；
  分析分层原理
  了解设计模式；


## 作业

  写一个程序：
  
      按架构分层，
      使用工厂模式生成多个线程并执行，
      从mysql读取数据到程序缓存，
      另起线程读取数据写到一个文件，
      通过流水日志发现耗时最多的步骤，
      分析程序瓶颈。
